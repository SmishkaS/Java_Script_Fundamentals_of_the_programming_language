/*
// 1. Почему код дает именно такие результаты?
var a = 1, b = 1, c, d;
c = ++a; alert(c); // 2 (увеличивает а на единицу и отдает новое значение, с присваивает это значение)
d = b++; alert(d); // 1 (увеличивает в на единицу но отдает старое значение, d присваивает это значение)
c = (2+ ++a); alert(c); // 5 (а == 2 после операции выше, увеличивается на единицу и отдает новое значени a = 3, с = 2 + 3)
d = (2+ b++); alert(d); // 4 (b == 2 после операции выше, увеличивает на единицу но отдает старое значени b = 2, d = 2 + 2)
alert(a); // 3 (первоначальное значение переменной a = 1  после операции выше дважды увеличенно на 1)
alert(b); // 3 (первоначальное значение переменной b = 1  после операции выше дважды увеличенно на 1)
*/

/*
// 2. Чему будет равен x?
var a = 2;
var x = 1 + (a *= 2); // (х = 5, обычная математика x = 1 + (2 * 2))
console.log(x) // (для проверки)
*/

/*
// 3. Объявить две целочисленные переменные — a и b и задать им произвольные начальные значения.
// Затем написать скрипт, который работает по следующему принципу:
// если a и b положительные, вывести их разность;
// если а и b отрицательные, вывести их произведение;
// если а и b разных знаков, вывести их сумму;
// Ноль можно считать положительным числом.
const a = 3, b = 9;
(a > b) ? x = a - b : x = b - a;
(a > 0 && b > 0) ? console.log(x) : x = a * b;
(a < 0 && b < 0) ? console.log (x) : x = a + b;
(a > 0 && b < 0 || a < 0 && b > 0) ? console.log (x) : 'где-то касяк'
*/

/*
// 4. Присвоить переменной а значение в промежутке [0..15].
// С помощью оператора switch организовать вывод чисел от a до 15.
const a = 6;
switch (a) {
    case 0:
        console.log(0);
    case 1:
        console.log(1);
    case 2:
        console.log(2);
    case 3:
        console.log(3);
    case 4:
        console.log(4);
    case 5:
        console.log(5);
    case 6:
        console.log(6);
    case 7:
        console.log(7);
    case 8:
        console.log(8);
    case 9:
        console.log(9);
    case 10:
        console.log(10);
    case 11:
        console.log(11);
    case 12:
        console.log(12);
    case 13:
        console.log(13);
    case 14:
        console.log(14);
    default:
        console.log(15);
}
*/

/*
// 5. Реализовать четыре основные арифметические операции в виде функций с двумя параметрами.
// Обязательно использовать оператор return.
function plus(a,b){return a + b} // console.log(plus(2,3))
function minus(a,b){return a - b} // console.log(minus(2,3))
function div(a,b){return (a / b).toFixed(2)} // console.log(div(2,3))
function multi(a,b){return a + b} // console.log(multi(2,3))
*/

/*
// 6. Реализовать функцию с тремя параметрами: function mathOperation(arg1, arg2, operation),
// где arg1, arg2 — значения аргументов, operation — строка с названием операции.
// В зависимости от переданного значения выполнить одну из арифметических операций
// (использовать функции из пункта 5) и вернуть полученное значение (применить switch).
function mathOperation(arg1, arg2, operation){
    switch(operation){
        case 'сложение':
            return plus(arg1, arg2);
            break;
        case 'вычитание':
            return minus(arg1, arg2);
            break;
        case 'деление':
            return div(arg1, arg2);
            break;
        case 'умножение':
            return multi(arg1, arg2);
            break;
    }
}
console.log(mathOperation(2,3, 'деление'))
*/

/*
// 7. * Сравнить null и 0. Объяснить результат.
// В зависимости от оператора сравнения null приводится к undefined || 0 || +0.
// В случае оператора сравнения ==, null приводится к undefined
console.log(null == 0) // false (undefined == 0)
console.log(null == undefined) // true (undefined == undefined)
// В случае простых оператарах сравнения (< || >) null приводится к 0
console.log(null > 0) // false (0 > 0)
console.log(null > undefined) // false (0 > undefined)
// При сложных оператарах сравнения (<= || >=) null приводится к +0
console.log(null >= 0) // true (+0 >= 0)
console.log(null >= undefined) // false (+0 >= undefined)
*/

/*
// 8. * С помощью рекурсии организовать функцию возведения числа в степень.
// Формат: function power(val, pow), где val — заданное число, pow –— степень.

function power(val, pow) {
    if (pow <= 0) return 1;
    else return val*power(val, pow-1);
}

let res = power(2, 3);
console.log(res)

// Как это работает? Сначала вызывается функция pow(2, 3). Она помещается в стек вызова функций.
// Далее, выполняется тело функции. Проверяется первое условие. Оно оказывается ложным, так как 3 <= 0 дает false.
// Поэтому идет переход на else и прежде чем выполнить оператор return, снова вызывается та же функция pow(2, 2).
// Выполнение функции pow(2, 3) останавливается, в стек помещается контекст выполнения второй функции pow(2, 2)
// и она запускается.
// Снова проверяется первое условие, и так до pow(2, 0), условие становится истинным и функция возвращает значение 1
// и рекурсия не идет дальше вглубь – она останавливается.
// Функция pow(2.0) завершается, ее контекст выполнения удаляется из стека вызовов и управление передается функции pow(2, 1).
// Но она частично уже выполнена. Поэтому, берется значение 1 от pow(2, 0), результат умножается на val=2
// и величина 2 возвращается функцией pow(2, 1).
// Контекст выполнения функции pow(2,1) удаляется из стека, управление переходит к вышестоящей функции pow(2,2)
// и здесь мы уже имеем результат умножения val*val, то есть, 2*2 = 4.
// Далее, возвращаемся к самой верхней функции pow(2,3), здесь 2*4=8 и этот результат вычисления рекурсивной функции.
*/